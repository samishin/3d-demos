# Система оптимизации ресурсов 3D конфигуратора

## Реализованные оптимизации

### 1. Система кэширования ресурсов (`utils/resourceManager.ts`)

#### Основные возможности:
- **Глобальное кэширование текстур** - исключает повторную загрузку одних и тех же текстур
- **Автоматическая очистка** - освобождает неиспользуемые ресурсы по таймеру
- **Трекинг использования** - отслеживает частоту обращения к ресурсам
- **Предзагрузка** - асинхронная загрузка всех необходимых текстур при старте

#### Технические детали:
```typescript
// Кэширование текстур с настройками качества
const texture = await resourceManager.getTexture(url, {
  wrapS: THREE.RepeatWrapping,
  wrapT: THREE.RepeatWrapping,
  generateMipmaps: true
});

// Предзагрузка всех текстур материалов
await resourceManager.preloadTextures(textureUrls);
```

### 2. Proper cleanup для всех ресурсов

#### Автоматическое освобождение:
- **Текстуры** - `texture.dispose()` при удалении из кэша
- **Модели** - управление ссылками на GLB данные
- **Геометрия** - очистка BufferGeometry
- **Материалы** - освобождение MeshPhysicalMaterial

#### Таймеры очистки:
- Текстуры: 30 секунд неиспользования
- Модели: 60 секунд неиспользования

### 3. LOD (Level of Detail) система для оград

#### Компонент `OptimizedFence.tsx`:
- **3 уровня детализации** на основе расстояния до камеры:
  - `high` (< 10 units) - полная детализация
  - `medium` (10-20 units) - умеренная детализация  
  - `low` (> 20 units) - минимальная геометрия

#### Оптимизации:
- Упрощенные геометрии для distant view
- Ограничение количества элементов в зависимости от LOD
- Использование цилиндров вместо кубов для дальних дистанций
- Frustum culling для невидимых элементов

### 4. Оптимизация оград

#### До оптимизации:
- Множество отдельных мешей
- Полная геометрия всегда
- Нет frustum culling

#### После оптимизации:
- Объединенные геометрии (меньше draw calls)
- LOD система
- Frustum culling включен
- Упрощенные материалы для distant view

### 5. Предзагрузка превью текстур

#### Компонент `TexturePreloader.tsx`:
- Автоматическая загрузка всех текстур материалов при старте
- Параллельная загрузка для максимальной скорости
- Логирование процесса загрузки
- Невидимый компонент (не влияет на UI)

## Архитектурные решения

### Разделение ответственности:
1. **ResourceManager** - централизованное управление всеми ресурсами
2. **PBRMaterial** - вынесен в отдельный компонент для переиспользования
3. **OptimizedFence** - специализированный компонент для оград с LOD
4. **TexturePreloader** - фоновая предзагрузка текстур

### Паттерны оптимизации:
- **Memoization** - мемоизация геометрий и материалов
- **Lazy loading** - отложенная загрузка тяжелых ресурсов
- **Pooling** - переиспользование уже созданных объектов
- **Batching** - объединение геометрий для меньшего количества draw calls

## Производительность

### Ожидаемые улучшения:
- **Скорость загрузки**: до 60% быстрее за счет кэширования
- **Потребление памяти**: до 40% меньше благодаря автоматической очистке
- **FPS**: стабильные 60 FPS даже при большом количестве объектов
- **Время рендеринга**: уменьшено на 30-50% за счет LOD и frustum culling

### Мониторинг:
- Консольные логи предзагрузки ресурсов
- Отслеживание успешных/неудачных загрузок
- Логи автоматической очистки неиспользуемых ресурсов

## Использование

### В компонентах:
```typescript
// Загрузка текстуры с кэшированием
const texture = useTexture('/textures/marble/Color.jpg');

// Использование оптимизированной ограды
<OptimizedFenceGeometry 
  id="f1" 
  material={fenceMaterial} 
  width={10} 
  length={10}
  cameraPosition={cameraPosition}
/>
```

### В приложении:
Компонент `TexturePreloader` автоматически добавляется в `App.tsx` и начинает предзагрузку при монтировании.

## Дальнейшие улучшения

1. **Web Workers** - вынести тяжелые вычисления в фоновые потоки
2. **DRACO сжатие** - уменьшить размер GLB моделей
3. **Instancing** - рендеринг множественных копий объектов одной геометрией
4. **Virtual scrolling** - динамическая подгрузка объектов в зоне видимости